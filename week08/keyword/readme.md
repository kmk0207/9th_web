# 📝 학습 목표

---

## **개념 이해**

- **지연 제어의 필요성**
    - 불필요한 API 호출, 이벤트 핸들러 과호출 문제를 사례로 설명할 수 있다.
    - Debounce와 Throttle의 개념적 차이(지연 실행 vs 주기적 제한)를 명확히 구분해 설명할 수 있다.
    - 입력 필드 검색, 스크롤 감시, 리사이즈 이벤트 등에서 각각 적합한 전략을 선택할 수 있다.

**내부 동작 원리**

- Debounce의 타이머 리셋 로직과 “마지막 호출만 유효” 동작을 코드 수준에서 설명할 수 있다.
- Throttle의 타임 윈도우 제어(leading/trailing edge) 동작 방식을 그림과 함께 설명할 수 있다.

<aside>
💡

이번 주차는 **이벤트 과호출 제어를** 주제로, Debounce/Throttle의 개념적 차이 → React 실전 구현 → 성능 분석과 UX 개선까지 전 과정을 학습합니다.

단순 지연 처리에 그치지 않고, “사용자 경험을 지키면서도 서버 부하를 줄이는 설계”를 목표로 합니다.

- 중앙 웹 파트장 매튜 / 김용민 - 

</aside>

# ⚠️ 스터디 진행 방법

---

1. **워크북 완료 후 스터디 참여**
    - 스터디 전, 워크북 내용을 **모두 작성**하고 이해되지 않은 부분을 준비합니다.
2. **스터디 미션 수행**
    - 워크북 완료 후 미션을 수행합니다.
    - 진행 내용과 문제점을 스터디 시간에 공유합니다.
    - **코드 리뷰**는 GitHub PR에서 상시 진행합니다.
3. **스터디 시간 구성**
    1. 각자 진행한 미션 중 **해결하지 못한 이슈 공유**
    2. 해당 문제를 **스터디원과 함께 해결 방법 공유**, 필요 시 같이 해결
    3. 미션 후 **피드백 공유 및 개선**
4. **주차별 미션 제출**
    - 매주 **워크북과 미션을 제출**합니다. (디자인은 개인 보완 가능)
    - 워크북 완료 후 [**워크북 피드백 폼 제출**](https://forms.gle/aXPWVZpDSfYTAiCd6?utm_source=chatgpt.com)
        - 특정 주제에 많은 피드백 요청이 들어올 경우, 피드백 이후 해당 내용을 바탕으로 **추가 강의 영상** 제공 예정 ([유튜브 구독](https://www.youtube.com/@yongcoding?utm_source=chatgpt.com))
    - **🍠 코드 리뷰 제출 기준**
        - 본인이 리뷰한 코드 **최소 1개**
        - 본인이 받은 리뷰를 코드에 **실제 반영한 것 최소 1개**
5. **스터디 인증샷**
    - 매주 대표 사진 **1장** 남기기
    - 이미지 임베드 또는 복사·붙여넣기 가능

# 📸 잠깐 ! 스터디 인증샷은 찍으셨나요?📸

---

* 스터디리더께서 대표로 매 주차마다 한 장 남겨주시면 좋겠습니다!🙆💗
 (사진을 저장해서 이미지 임베드를 하셔도 좋고, 복사+붙여넣기해서 넣어주셔도 좋습니다!)

[]()

# 🎯 핵심 키워드

---

<aside>
💡 주요 내용들에 대해 조사해보고, 자신만의 생각을 통해 정리해보세요!
레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 됩니다.
조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**

🍠 이모지가 달린 부분은, 여러분들이 직접 조사하여, 추가 작성하거나, 실습해보실 부분이니, 꼭 진행해주셔야 합니다!

</aside>

- **`Debounce`**는 무엇인가요?
    
    ### **`Debounce`**는 무엇인가요?
    
    ---
    
    **`Debounce`**는 **이벤트가 연달아 터질 때 실행을 잠깐 지연시켜요.**
    그리고 **마지막 이벤트 뒤로 일정 시간 동안 더 이상 이벤트가 안 오면 그때 한 번만 실행돼요.**
    
    검색어 자동완성, 입력 폼 검사, 창 리사이즈 처리 같은 데서 자주 써요.
    
    ---
    
    ### 왜 쓰나요?
    
    - 짧은 시간에 함수가 수십 번 불리면 비용이 커요. → **불필요한 호출을 미뤄줘요.**
    - 사용자가 타자를 멈출 때까지 기다렸다가 **마지막 입력 기준으로 딱 한 번 실행돼요.**
    - 결과적으로 **네트워크/연산 낭비를 줄이고**, 깔끔한 UX를 만들어요.
    
    ---
    
    ### 시각적 흐름
    
    아래는 300ms 디바운스를 예로 든 타임라인이에요.
    키 입력이 계속 이어지면 실행이 계속 **미뤄져요**. 멈추고 300ms 지나면 **그때 실행돼요**.
    
    ```mermaid
    gantt
    dateFormat  X
    axisFormat  %Lms
    title Debounce 타임라인 (300ms)
    
    section 키 입력
    A 입력 :milestone, a, 0, 0
    B 입력 :milestone, b, 100, 0
    C 입력 :milestone, c, 200, 0
    
    section 대기 (300ms)
    A 이후 대기 :active, 0, 300
    B 이후 대기 :active, 100, 300
    C 이후 대기 :active, 200, 300
    
    section 실행
    실행 (C 기준) :milestone, exec, 500, 0
    ```
    
    - A(0ms), B(100ms), C(200ms) 모두 300ms 안에 잇달아 들어와서 실행이 **미뤄져요**.
    - C 이후 300ms 동안 추가 입력이 없어서 **500ms에 한 번 실행돼요**.
    
    ---
    
    ### 예시: 검색 자동완성
    
    사용자가 검색창에 글자를 입력할 때마다 API를 호출하면 어떻게 될까요?
    
    예를 들어 `"apple"`을 치는 동안 5글자를 빠르게 입력하면
    
    `a → ap → app → appl → apple`
    이렇게 **5번이나 API 요청이 발생할 수 있어요.**
    
    이건 서버 입장에서도 부담이고, 사용자 입장에서도 느려 보이죠.
    그래서 **“잠깐 기다렸다가, 입력이 끝났을 때 한 번만 호출”** 하도록 만드는 게 **`Debounce`**의 역할이에요.
    
    **🔍 `Debounce`를 적용하지 않은 코드**
    
    ```tsx
    <input onChange={(e) => {
      fetch(`/api/search?q=${e.target.value}`);
    }} />
    ```
    
    - 사용자가 키보드를 칠 때마다 `onChange`가 즉시 실행돼요.
    - `"apple"`을 입력하면 **5번 fetch 요청**이 발생합니다.
    - 검색 API를 이렇게 자주 부르면 서버 부하도 크고, UX도 좋지 않아요.
    
    **✅ `Debounce`를 적용한 코드**
    
    ```tsx
    const debouncedSearch = debounce((query) => {
      fetch(`/api/search?q=${query}`);
    }, 300);
    
    <input onChange={(e) => debouncedSearch(e.target.value)} />
    ```
    
    **🔍 동작 방식**
    
    1. 사용자가 키를 누를 때마다 `debouncedSearch`가 호출돼요.
    2. 하지만 바로 실행하지 않고 **300ms 기다립니다.**
    3. 300ms 안에 또 입력이 들어오면 **기존 타이머를 취소하고 새로 시작**해요.
    4. 사용자가 입력을 멈추고 300ms 동안 아무 키도 누르지 않으면
        
        그제서야 `fetch('/api/search?q=...')`가 실행돼요.
        
    
    👉 즉, “입력이 멈춘 뒤 0.3초 뒤에 딱 한 번 실행”되는 거예요.
    
- **`Throttling`**은 무엇인가요?
    
    ### **`Throttling`**은 무엇인가요?
    
    ---
    
    **`Throttling`**은 **이벤트가 연달아 발생하더라도 일정 시간마다 한 번만 실행되도록 제한해요.**
    
    즉, **짧은 간격으로 여러 번 호출되더라도 주기적으로 딱 한 번씩 실행돼요.**
    
    스크롤, 드래그, 창 리사이즈, 버튼 연타 같은 **지속적이거나 빈번한 이벤트 처리**에 자주 사용돼요.
    
    ---
    
    ### 왜 쓰나요?
    
    - 짧은 시간에 함수가 수십 번 불리면 비용이 커요. → **주기적으로 실행을 제한해줘요.**
    - 사용자가 계속 이벤트를 발생시켜도 **정해진 주기마다 한 번만 실행돼요.**
    - 결과적으로 **CPU 부하를 줄이고**, **자연스러운 실시간 반응**을 유지할 수 있어요.
    
    ---
    
    ### 시각적 흐름
    
    아래는 300ms 스로틀 예시 타임라인이에요.
    
    이벤트가 여러 번 발생해도 실행은 **300ms마다 딱 한 번만** 일어나요.
    
    ```mermaid
    gantt
    dateFormat  X
    axisFormat  %Lms
    title Throttle 타임라인 (300ms)
    
    section 이벤트 발생
    A 발생 :milestone, a, 0, 0
    B 발생 :milestone, b, 100, 0
    C 발생 :milestone, c, 200, 0
    D 발생 :milestone, d, 400, 0
    E 발생 :milestone, e, 700, 0
    
    section 실행
    실행 (A 기준) :milestone, exec1, 0, 0
    실행 (D 기준) :milestone, exec2, 400, 0
    실행 (E 기준) :milestone, exec3, 700, 0
    
    ```
    
    - A~C가 300ms 안에 몰려와도 **A 한 번만 실행돼요.**
    - D는 A 이후 300ms가 지났으므로 다시 실행돼요.
    - E도 D 이후 300ms가 지나 실행돼요.
    
    👉 즉, **“이벤트가 많아도 일정 간격마다 한 번씩 실행되는 구조”**예요.
    
    ---
    
    ### 예시: 스크롤 이벤트 처리
    
    사용자가 스크롤할 때마다 화면을 업데이트하는 상황을 생각해볼게요.
    
    이벤트가 너무 자주 발생하면 렉이 걸리거나 프레임이 떨어질 수 있어요.
    
    **🧱 `Throttling`을 적용하지 않은 코드**
    
    ```tsx
    window.addEventListener("scroll", () => {
      console.log("스크롤 중...");
    });
    ```
    
    - 스크롤 이벤트가 수백 번 발생하면 `console.log`도 그만큼 실행돼요.
    - CPU 점유율이 높아지고, 스크롤이 끊기거나 느려질 수 있어요.
    
    **✅ `Throttling`을 적용한 코드**
    
    ```tsx
    const throttledScroll = throttle(() => {
      console.log("스크롤 중...");
    }, 300);
    
    window.addEventListener("scroll", throttledScroll);
    ```
    
    🔍 동작 방식
    
    1. 사용자가 스크롤을 시작하면 `throttledScroll`이 즉시 실행돼요.
    2. 이후 **300ms 동안은 실행이 잠시 막혀요.**
    3. 300ms가 지나면 **다음 이벤트를 다시 허용해요.**
    4. 즉, 계속 스크롤 중이라도 **0.3초마다 한 번만 실행**돼요.
    
    👉 “**이벤트를 주기적으로 제한해서 부드럽게 처리**”하는 거예요.
    
- **`Debounce`** vs **`Throttling`** 요약
    
    ## **`Debounce`** vs **`Throttling`** 요약
    
    > **TIP**: **입력이 멈춘 뒤 한 번이면 `Debounce`**, **계속 반응해야 하면 `Throttling`**.
    > 
    
    | 항목 | **`Debounce`** | **`Throttling`** |
    | --- | --- | --- |
    | 정의 | **마지막 이벤트 후** 지연 시간 지나면 1회 실행 | **지정 간격마다** 최대 1회 실행 |
    | 실행 시점 | 입력이 **멈춘 뒤** 실행 | 이벤트가 계속 와도 **주기적으로** 실행 |
    | 적합한 사례 | 검색 자동완성, 입력 검증, 저장/검사 버튼 | 스크롤/리사이즈, 드래그, 마우스 이동 |
    | 사용자 경험 | 결과가 **확정된 뒤** 응답 → 안정적 | **지속적으로** 반응 → 실시간 느낌 |
    | 장점 | 불필요 호출 최소화, 네트워크 절약 | 프레임 드랍 완화, 부드러운 인터랙션 |
    | 주의점 | 지연이 길면 응답이 느리게 느껴질 수 있음 | 주기 사이 값이 **건너뛰어질 수 있음** |
- **`Debounce`** 구글링 후 개념 정리 및 코드 작성해보기 🍠
    
    ### 📚 참고자료
    
    [Debounce vs Throttle: Definitive Visual Guide](https://kettanaito.com/blog/debounce-vs-throttle)
    
    ---
    
    - **`Debounce`** 개념 정리 🍠
        
        디바운스는 짧은 시간 동안 연속해서 발생하는 이벤트를 즉시 처리하지 않고 마지막 이벤트가 끝난 뒤 일정 시간이 지났을 때 함수를 한 번만 실행하는 기술이다. 검색어 자동완성처럼 사용자가 입력을 멈출 때까지 기다렸다가 API를 호출해야 하는 상황에서 불필요한 서버 요청과 연산 낭비를 줄이기 위해 주로 사용한다. 결과적으로 시스템의 성능을 최적화하고 네트워크 리소스를 아끼며 사용자에게 더 부드럽고 효율적인 인터페이스 경험을 제공한다.
        
    - **`Debounce`** 코드 작성 🍠
    
    ```jsx
    import { useState, useEffect } from 'react';
    
    // <T>: 제네릭 타입 (문자열, 숫자 등 어떤 값이든 들어올 수 있음)
    // value: 지연시킬 값 (예: 검색어 state)
    // delay: 기다릴 시간 (ms 단위)
    export function useDebounce<T>(value: T, delay: number): T {
      // 1. 지연된 값을 관리할 state
      const [debouncedValue, setDebouncedValue] = useState<T>(value);
    
      useEffect(() => {
        // 2. delay 시간 후에 debouncedValue를 업데이트하는 타이머 설정
        const timer = setTimeout(() => {
          setDebouncedValue(value);
        }, delay);
    
        // 3. cleanup 함수: value나 delay가 바뀌면(새로운 입력이 들어오면)
        // 실행 대기 중이던 기존 타이머를 취소해버림! (핵심)
        return () => {
          clearTimeout(timer);
        };
      }, [value, delay]); // value가 변경될 때마다 이 효과가 재실행됨
    
      // 4. 최종적으로 지연된 값을 반환
      return debouncedValue;
    }
    ```
    
- **`Throttling`** 구글링 후 개념 정리 및 코드 작성해보기 🍠
    
    ### 📚 참고자료
    
    [Debounce vs Throttle: Definitive Visual Guide](https://kettanaito.com/blog/debounce-vs-throttle)
    
    ---
    
    - **`Throttling`** 개념 정리 🍠
        
        스로틀링은 스크롤이나 리사이즈처럼 연속적이고 빈번하게 발생하는 이벤트를 일정한 시간 간격으로 제한하여 주기적으로 딱 한 번만 실행되도록 만드는 최적화 기술이다. 짧은 시간 안에 수없이 호출되는 함수 실행 횟수를 강제로 조절함으로써 CPU 과부하를 막고 브라우저 성능 저하를 방지하는 데 주로 사용한다. 사용자가 끊임없이 입력을 발생시키더라도 정해진 주기에 맞춰 실행되므로 시스템 자원을 효율적으로 관리하면서도 실시간 반응성을 유지할 수 있다.
        
    - **`Throttling`** 코드 작성 🍠
        
        ```jsx
        import { useState, useEffect } from 'react';
        
        // <T>: 제네릭 타입 (문자열, 숫자 등 어떤 값이든 들어올 수 있음)
        // value: 지연시킬 값 (예: 검색어 state)
        // delay: 기다릴 시간 (ms 단위)
        export function useDebounce<T>(value: T, delay: number): T {
          // 1. 지연된 값을 관리할 state
          const [debouncedValue, setDebouncedValue] = useState<T>(value);
        
          useEffect(() => {
            // 2. delay 시간 후에 debouncedValue를 업데이트하는 타이머 설정
            const timer = setTimeout(() => {
              setDebouncedValue(value);
            }, delay);
        
            // 3. cleanup 함수: value나 delay가 바뀌면(새로운 입력이 들어오면)
            // 실행 대기 중이던 기존 타이머를 취소해버림! (핵심)
            return () => {
              clearTimeout(timer);
            };
          }, [value, delay]); // value가 변경될 때마다 이 효과가 재실행됨
        
          // 4. 최종적으로 지연된 값을 반환
          return debouncedValue;
        }
        ```
        

### 아래 사이트에서 직접 체험해보며 이해할 수 있어요!

# 🍠 미션 1 - Debounce를 활용하여 불필요한 호출 막아보기

---

<aside>
🔥

**`Debounce`**를 사용해 사용자의 입력이 끝날 때까지 API 호출을 지연시켜 **불필요한 서버 요청을 줄이는 방법**을 학습합니다.

**`Debounce`**를 적용한 검색 기능과 함께 **`TanStack Query`**의 **`useInfiniteQuery`**를 연계하여 **사용자 입력에 반응하는 동적 데이터 처리 및 무한 스크롤 기능**을 구현해봅니다.

</aside>

---

### 🎬 강의 영상

https://www.youtube.com/watch?v=42aLY3Y6erg&t=8s

---

### ✅ 체크리스트

[콘솔은 debounce 동작 이해도를 높이기 위해 임의로 넣어둔 것입니다!](attachment:d8b62bba-0d10-4957-9907-bec749c6af98:화면_기록_2025-04-17_오전_12.38.14.mov)

콘솔은 debounce 동작 이해도를 높이기 위해 임의로 넣어둔 것입니다!

[ㅌ,ㅏ,ㅇ,ㅣ,ㅂ,ㅅ,ㅡ,ㅋ,ㅡ,ㄹ,ㅣ,ㅂ,ㅌ,ㅡ 를 입력하는 동안에는 api 요청이 가지 않는 것을 확인하실 수 있습니다!](attachment:9c2d7b29-28dd-4fa3-8d6d-d29192990920:화면_기록_2025-04-17_오전_12.44.00.mov)

ㅌ,ㅏ,ㅇ,ㅣ,ㅂ,ㅅ,ㅡ,ㅋ,ㅡ,ㄹ,ㅣ,ㅂ,ㅌ,ㅡ 를 입력하는 동안에는 api 요청이 가지 않는 것을 확인하실 수 있습니다!

1) **`useDebounce`** 구현

- [x]  **`useDebounce`** 커스텀 훅을 직접 만들어보았나요?
    - [x]  값 지연형 `useDebounce(value, delay)`를 **직접 구현했나요?**
    - [x]  언마운트/의존성 변경 시 타이머를 **깨끗하게 정리했나요?** (`clearTimeout`)
    - [x]  지연 시간(`delay`) 변경이 **즉시 반영되도록 처리했나요?**

2) **`useDebounce`** 실제 적용

- [x]  검색 입력에 **`useDebounce`** 적용
    - [x]  입력 값을 **`useDebounce`**로 **지연된 값(`debouncedQuery`)으로 만들었나요?**
    - [x]  빈 문자열/공백만 입력일 때 **요청이 나가지 않도록 막았나요?** (`enabled`)
    - [x]  지연 시간은 **200–500ms(권장 300ms)** 로 **적절히 설정해 주세요.**
- [x]  `useInfiniteQuery` 연계
    - [x]  `queryKey`에 **지연된 값**(`["search", debouncedQuery]`)을 **포함했나요?**
    - [x]  빈 검색어일 땐 **쿼리가 실행되지 않도록 설정했나요?** (`enabled`)
    - [x]  `getNextPageParam`으로 **cursor/nextCursor** 기반 페이지네이션을 **구현했나요?**
    - [x]  `staleTime`/`cacheTime`을 조정해 **불필요한 재요청을 줄여주세요.**

3) **`useDebounce`** 검증

- [x]  불필요한 서버 요청이 일어나지 않았는지 확인해보셨나요?
    - [x]  이를 통해 **불필요한 서버 요청을 줄일 수 있었는지** 확인해보세요. (브라우저 Inspect 기능의 네트워크 탭 활용)
        - 브라우저의 **개발자 도구(Inspect → Network 탭)**를 활용해 요청 타이밍을 체크해주세요. 검색창에 검색어를 입력할 때 **요청이 입력 직후 바로 발생하지 않고, 일정 시간 후 발생하는 모습**을 영상을 촬영하여 토글을 열어 첨부해주세요.

### 🍠 미션 1. 제출

- 깃허브 주소
- 실행 영상

---

# 🍠 미션 2.  Throttling을 활용하여 불필요한 호출 막아보기

<aside>
🔥

**미션 2에서는 `Throttle`을 활용하여 이벤트가 과도하게 발생하는 상황에서도 일정 간격으로만 처리되도록 제어하는 방법을 배우는 것이 목표입니다.**

이를 통해 스크롤, 리사이즈, 마우스 이동 등에서 발생하는 **빈번한 이벤트 호출을 효율적으로 제어**할 수 있으며, 불필요한 연산을 줄이고 **애플리케이션 성능을 향상**시킬 수 있습니다.

</aside>

---

### 🎬 강의 영상

https://www.youtube.com/watch?v=Qo9rYmtMD9M&t=3s

---

### ✅ 체크리스트

1) **`useThrottle`** 구현

- [x]  **`useThrottle`**(value, interval)을 **직접 만들어보셨나요?**
- [x]  **언마운트/의존성 변경 시 타이머·플래그를 정리**하도록 구현하셨나요? (`clearTimeout` 등)
- [x]  타입스크립트 사용 시 **제네릭/콜백 파라미터 타입**을 올바르게 지정하셨나요?

2) **`useThrottle`** 실제 적용

- [x]  **`useThrottle`**을 활용하여 **이벤트가 일정 주기마다 한 번만 실행되도록 제어**하셨나요?
    - 예: 사용자가 **스크롤을 빠르게 내릴 때**, **`useThrottle`**을 통해 이벤트 호출 빈도를 제한하여 성능을 최적화합니다.
        
        [해당 영상은 무한스크롤에 useThrottle을 적용하여 3초에 한 번씩만 LP 정보를 받아오도록 한 영상입니다! useThrottle이 적용됨을 보여주기 위해 3초로 적용한 것이니 여러분들은 더 짧게(1초) 설정하셔도 무방합니다!](attachment:1a9962d0-bd75-4174-85f0-124d1acee051:화면_기록_2025-04-16_오후_11.57.59.mov)
        
        해당 영상은 무한스크롤에 useThrottle을 적용하여 3초에 한 번씩만 LP 정보를 받아오도록 한 영상입니다! useThrottle이 적용됨을 보여주기 위해 3초로 적용한 것이니 여러분들은 더 짧게(1초) 설정하셔도 무방합니다!
        
- [x]  **`useThrottle`**을 활용하여 **이벤트가 일정 주기마다 한 번만 실행되도록 제어**하셨나요?

3) **`useThrottle`** 검증

- [x]  브라우저의 **개발자 도구(Inspect → Performance 탭)** 등을 활용해 **`useThrottle` 적용 전후의 성능 차이를 확인**해보셨나요?
- [x]  **`useThrottle`** 훅이 잘 작동하는 모습을 캡처 영상 또는 GIF로 촬영해 제출해주세요.
    
    → 예: 스크롤할 때 콘솔 로그가 계속 출력되지 않고 일정 간격으로만 출력되는 모습 등.
    

### 🍠 미션 2. 제출

- 깃허브 주소
- 실행 영상

---

# 🍠 미션 3.  Sidebar 다시 생각하며 리팩토링 해보기

<aside>
🔥

지난 **Chapter 6 워크북**에서는 오직 “완성된 화면”만 보고 **Sidebar**를 직접 구현해 보는 실습을 진행했습니다. 해 보니 어떠셨나요?

- “직접 만들어 보니 쉽진 않았지만, 구현된 걸 보니까 뿌듯했고 성장에 큰 도움이 되었다”는 분도 있었을 것이고,
- “강의 영상 따라가기에도 벅찬데, 도움 없이 직접 구현하라니 시간도 없고 너무 어려웠다”고 느낀 분도 있었을 거예요.

사실 지난 미션은 여러분이 **데모데이에서 느끼게 될 감정**을 미리 맛보는 미션이기도 했습니다. 

데모데이에서 기획자/디자이너가 제공하는 화면과 요구 기능은 지금과 비교가 안 될 정도로 더 까다롭습니다.

그리고 중요한 메시지 하나, **어려운 문제 앞에서는 언제까지나 강의 영상만으로 모든 기능을 커버할 수 없다**는 점을 꼭 경험하셨으면 했어요.

그동안 정말 많은 내용을 배웠습니다. 이제는 배운 것들을 **유기적으로 조합**해, 처음 보는 기능도 스스로 접근해 보는 연습이 필요합니다.

돌이켜 보면, 다음의 내용만 잘 활용해도 6주차의 사이드바는 충분히 만들어 볼 수 있어요.

- 0주차 핸드북의 **CSS 기본기**
- 2주차의 **useState**
- 3주차의 **useEffect**, **Tailwind CSS**
- 4주차의 **커스텀 훅**

## 🎯 미션의 의도

- 제한된 힌트 속에서 **요구사항을 분석**하고,
- 배운 개념을 **적절히 조합**하며,
- **처음 보는 문제를 스스로 해결**하는 역량을 키우는 것.

## 🧭 권장 학습 방법

1. **먼저 스스로 한 번 구현**해 보세요. (실패해도 괜찮습니다. 그 자체가 학습입니다.)
2. 생소한 개념은 **검색**하고, **AI를 도구처럼 활용**해 보세요.
    
    > 단, 정답을 바로 요구하기보다 “접근 방법”과 “이유”를 먼저 물어보는 습관을 추천합니다.
    > 
3. 막히는 지점이 명확해지면, 그때 **강의 영상**으로 확인하며 빈 곳을 채우세요.
4. 영상 시청 후에는 다시 코드로 돌아와 **리팩터링**까지 해 보세요. (가독성, 컴포넌트 분리, 훅 추출 등)
</aside>

---

### 🎬 강의 영상

https://youtu.be/k7kK_wz_0Ss?si=1Ou2hSB-4ubzPMjR

### ✅ 체크리스트

**1) Sidebar UI 구현 및 애니메이션 적용**

- [x]  **Sidebar UI**를 구현하셨나요?
- [x]  Sidebar가 **자연스럽게 열리고 닫히도록 애니메이션 효과**를 주셨나요?
    - [x]  CSS Handbook의 Animation 부분을 참고해서 Tailwind CSS의 **Transition 유틸리티 클래스**를 검색하고 적용해 보세요.
        
        [transition-property - Transitions & Animation](https://tailwindcss.com/docs/transition-property)
        

**2) `useSidebar` 커스텀 훅 구현**

- [x]  **Sidebar**의 **열림/닫힘 상태 관리**가 필요하다는 것을 인지하셨나요?
    - [x]  **Sidebar**를 열 수 있는 **`open()` 함수**를 만드셨나요?
    - [x]  **Sidebar**를 닫을 수 있는 **`close()` 함수**를 만드셨나요?
    - [x]  **Sidebar** 상태를 토글할 수 있는 **`toggle()` 함수**를 만드셨나요?
    - [x]  만든 상태와 함수를 활용해서 햄버거 메뉴 클릭 시 **Sidebar**가 **자연스럽게 열고 닫히는 기능**을 연결하셨나요?
- [x]  이 상태와 함수들을 **`useSidebar` 커스텀 훅**으로 만들어 재사용성을 확보하셨나요?
    - [x]  조금 어려우신 분은 Chapter 4 커스텀 훅을 어떻게 만들었었는지 워크북을 통해 확인해보세요.

**3) 접근성 개선: ESC 키로 닫기**

- [x]  키보드의 **`ESC` 버튼**을 눌러도 Sidebar 컴포넌트가 닫힐 수 있도록 기능을 구현하셨나요?
    - [x]  **`keydown` EventListener**를 활용해주세요.
    - [x]  **`useEffect`**의 **클린업 함수**를 통해 EventListener를 등록 해제(취소)하여 메모리 누수를 방지하셨나요?
        - [x]  이 개념이 헷갈리신다면 **`Chapter 3`** 워크북 **`useEffect`** 부분을 확인해보세요.

**4) 사용성 개선: 배경 스크롤 방지**

- [x]  사이드바가 열렸을 때 **뒷배경 콘텐츠가 스크롤 되는 현상**이 발생하는지 확인하고 인지하셨나요?
    - [x]  임의로 긴 텍스트를 넣어 스크롤 현상을 확인해 보셨나요.
- [x]  이 부분을 어떻게 해결할 수 있을지 한번 직접 AI도 좋고, 검색도 좋고 한번 해결해보세요!
    - [x]  AI 또는 검색을 통해 이 문제를 **해결**하셨나요?
    - **어떤 방식으로 검색**하고 **어떤 CSS 속성**을 활용하여 해결했는지 기록해 두셨나요?

### 🍠 미션 3. 제출

- 깃허브 주소
- 실행 영상

# 🍠 워크북 피드백

---

<aside>
💡

여러분들이 워크북을 학습하며 느낀 **좋았던 점**, **아쉬웠던 점**, **개선이 필요한 부분**을 자유롭게 남겨주세요.

여러분의 솔직한 의견은 다음 기수와 현재 진행하고 있는 웹 파트 스터디를 더 발전시키는 데 큰 힘이 됩니다. 🙌

**📌 설문 안내**

**제출 시점 :** 각 주차 워크북 학습을 마친 뒤 **반드시 제출**해주세요.

(제출하지 않으면 해당 주차 **워크북 미이수**로 간주됩니다.)

</aside>

[](https://forms.gle/PCLJq6NUn1qBd1Ha8)

# 🍠 코드 리뷰

---

<aside>
💡

워크북 하단에 아래 내용을 정리해 제출해 주세요. (제출용 폼은 추후 제공 예정)

1. **내가 리뷰한 내용**
    - 직접 리뷰한 코드 내용을 캡처하여 업로드 (**`GitHub Pull Request`** 캡처 권장)
2. **리뷰 반영 결과**
    - 받은 피드백을 반영한 개선된 코드와 그 캡처를 함께 업로드 (**`GitHub Pull Request`** 캡처 권장)

> 💬 아직 코드 작성을 하지 않은 경우
> 
> 
> 스터디 참여 인증 또는 워크북 피드백을 작성해 제출해 주세요.
> 
</aside>

- 내가 리뷰한 내용을 캡처해 업로드
    
    **예시**
    
    ![스크린샷 2025-09-05 오후 12.46.40.png](attachment:39549968-68c3-4416-b41f-423fd1f7fd79:스크린샷_2025-09-05_오후_12.46.40.png)
    
- 받은 리뷰를 반영하여 개선한 코드와 캡처 업로드
    
    **예시**
    
    ![스크린샷 2025-09-05 오후 12.47.34.png](attachment:01011e3f-c9fd-4041-bdd5-4da72a805955:스크린샷_2025-09-05_오후_12.47.34.png)
    

# 🍠 트러블 슈팅

---

<aside>
🍠 실습을 진행하면서 생긴 문제들 또는 어려웠던 내용에 대해서, 이슈 - 문제 - 해결 순서로 작성해 주세요.

</aside>

- 🍠 이슈 No.1 (예시, 서식만 복사하시고 지워주세요.)
    
    **`이슈`**
    
    👉 React 상태 관리 중 `useState`로 배열을 업데이트할 때, 원본 배열이 변경되지 않는 문제가 발생했다.
    
    ---
    
    **`문제`**
    
    👉 `push()` 메서드를 사용해 상태 배열에 새 요소를 추가했지만, React가 상태 변경을 감지하지 않아 화면이 갱신되지 않았다.
    
    ```jsx
    const [items, setItems] = useState<string[]>([]);
    
    function addItem(newItem: string) {
      items.push(newItem); // 상태 직접 변경
      setItems(items);     // 동일 참조 전달
    }
    ```
    
    React는 상태 변경 여부를 **참조(Reference)** 기준으로 판단하기 때문에, 기존 배열을 직접 변경하면 리렌더링이 일어나지 않는다.
    
    ---
    
    **`해결`**
    
    👉 기존 배열을 복사하여 새로운 배열 객체를 만들어 전달했다.
    
    ```jsx
    function addItem(newItem: string) {
      setItems([...items, newItem]); // 새로운 배열 생성
    }
    ```
    
    이로써 React가 새로운 참조를 감지하여 정상적으로 리렌더링이 발생했다.
    

# 🥕 **타이핑할 때마다 서버를 공격하지 마세요: Debouncing과 Throttling 실무 이야기**

---

<aside>
🥕

왜 **Debouncing**과 **Throttling**을 사용해야하는지 실무 이야기를 바탕으로 재밌게 정리해보았어요.

참고로, 이 글의 내용은 전부 **Perplexity**를 기반으로 정리했습니다.

</aside>

[ **타이핑할 때마다 서버를 공격하지 마세요: Debouncing과 Throttling 실무 이야기**](https://www.notion.so/Debouncing-Throttling-2a8b57f4596b81688630da34f3e13d7e?pvs=21)

# 🍠 학습 회고

---

<aside>
📢 이번 주차 워크북을 해결해보면서 어땠는지 **회고**해봅시다.

- **핵심 키워드**에 대해 완벽하게 이해했는지? 
- **이해한 점 - 어려운 점 (개선 방법) - 회고** 순서로 작성해주세요.
- **참고 자료**가 있다면 아래에 남겨주세요.

</aside>

- 📢 학습 회고 (예시, 서식만 복사하시고 지워주세요.)
    - **프론트엔드 배포, Vercel 활용**
        - **이해한 점**: Vercel은 프론트엔드 프로젝트를 **빠르고 간편하게 배포**할 수 있는 플랫폼입니다.
            
            GitHub 연동, 환경변수 설정, 커스텀 도메인 연결 등 배포 과정 대부분이 GUI와 CLI로 쉽게 처리되며, SPA 환경에서도 라우팅 문제를 `vercel.json` 설정으로 해결할 수 있습니다.
            
            - 예시:
                
                ```bash
                # CLI로 배포
                vercel         # Preview 배포
                vercel --prod  # Production 배포
                ```
                
                ```json
                // SPA 라우팅 문제 해결
                {
                  "routes": [
                    { "src": "/[^.]+", "dest": "/index.html", "status": 200 }
                  ]
                }
                ```
                
        - **어려운 점 (개선 방법)**: SPA 기반 프로젝트는 새로고침 시 404 문제가 발생할 수 있으며, 환경변수 관리, 커스텀 도메인 연결 과정이 처음에는 헷갈렸습니다.
            - 개선 방법: `vercel.json` 설정으로 SPA 라우팅 문제를 해결하고, Vercel Dashboard에서 환경변수와 DNS 설정을 직접 확인하면서 반복적으로 배포 실습을 진행했습니다.
            - 예시:
                
                ```tsx
                // 환경변수 사용
                const api = axios.create({
                  baseURL: import.meta.env.VITE_API_URL,
                  headers: { 'Content-Type': 'application/json' },
                });
                
                ```
                
        - **회고**: 실제 배포 과정을 경험해보니, 로컬 환경과 다른 실제 서비스 환경에서의 테스트 필요성을 이해할 수 있었습니다.
            
            앞으로 프로젝트를 진행할 때, GitHub 연동과 Vercel 배포를 활용해 **즉시 테스트 가능한 환경**을 만들고, SPA 라우팅 문제와 환경변수를 신경 써서 안정적으로 서비스를 운영할 수 있을 것 같습니다.
            
        
        ---
        
        ### 참고 자료
        
        [개발자 매튜 | 우리는 Vercel로 간다! 프론트엔드 배포 가이드](https://www.yolog.co.kr/post/vercel-deployment)
        

# 🤔 참고 자료

---

[Debounce vs Throttle: Definitive Visual Guide](https://kettanaito.com/blog/debounce-vs-throttle)

# 🛡️ 저작권

---

**© 2025 [Kim Yongmin (Matthew)](https://www.youtube.com/@yongcoding). All rights reserved.**