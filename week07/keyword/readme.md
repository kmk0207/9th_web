# 📝 학습 목표

---

- **개념 이해**
    - 낙관적 업데이트가 해결하는 문제(지연 체감, 비일관 상태)를 서술할 수 있다.
    - TanStack Query에서 **useMutation** 라이프사이클(`onMutate → onError → onSettled`)의 책임을 구분해 설명할 수 있다.
    - `invalidateQueries`와 `setQueryData`의 차이와 사용 시점을 사례와 함께 설명할 수 있다.
- **구현 역량**
    - ToDo 생성, 닉네임 변경, 좋아요 토글에 낙관적 업데이트를 적용하고 즉시 UI 반영을 구현할 수 있다.
    - `Query Key Factory`를 사용해 목록/단건/필터 조합 키를 일관되게 설계하고, 부분 무효화 범위를 제어할 수 있다.
    - 실패 시 롤백 컨텍스트를 활용해 원복하고, 중복 클릭·응답 순서 뒤바뀜 등 경쟁 상태를 방지하는 코드를 작성할 수 있다.
- **설계·품질**
    - 멱등성(요청 ID), 임시 식별자(로컬 UUID), 재시도 정책을 포함한 실패/충돌 롤백 전략을 설계할 수 있다.
    - 느린 네트워크, 오프라인/재연결 시나리오에서 큐잉·재시도·만료 정책을 설계할 수 있다.
    - 단위/통합 테스트로 낙관적 반영→실패→롤백 흐름을 재현하고 검증할 수 있다.
- **UX·측정**
    - “상호작용 → 시각 반영”까지의 체감 대기시간, 재시도율/실패율, 이탈률 등 핵심 지표를 정의하고 로깅 포인트를 설계할 수 있다.
    - A/B 실험(낙관적 업데이트 On/Off)을 설계하고 결과를 해석해 개선안을 도출할 수 있다.
    - 에러 보호 장치(되돌리기 토스트, 자동 비활성화 임계치, 버튼 디세이블)를 적용할 수 있다.
- **협업·리뷰**
    - PR에서 낙관적 업데이트 적용 코드에 대한 리뷰 기준(키 설계, 롤백 안전성, 경쟁 상태 대응)을 제시하고 피드백을 반영할 수 있다.
    - 워크북 완성본과 미션 산출물(깃허브 링크, 실행 영상)을 제출 형식에 맞춰 정리할 수 있다.

<aside>
💡 이번 주차는 TanStack Query의 **useMutation**과 `Query Key Factory`를 기반으로 낙관적 업데이트를 개념→구현→검증까지 전 과정으로 익히는 것이 목표입니다. 즉시 반응하는 UI를 만들되, 실패 시에도 안전하게 원복되는 설계·테스트·UX 측정을 함께 체득합니다.

- 중앙 웹 파트장 매튜 / 김용민 -

</aside>

# ⚠️ 스터디 진행 방법

---

1. **워크북 완료 후 스터디 참여**
    - 스터디 전, 워크북 내용을 **모두 작성**하고 이해되지 않은 부분을 준비합니다.
2. **스터디 미션 수행**
    - 워크북 완료 후 미션을 수행합니다.
    - 진행 내용과 문제점을 스터디 시간에 공유합니다.
    - **코드 리뷰**는 GitHub PR에서 상시 진행합니다.
3. **스터디 시간 구성**
    1. 각자 진행한 미션 중 **해결하지 못한 이슈 공유**
    2. 해당 문제를 **스터디원과 함께 해결 방법 공유**, 필요 시 같이 해결
    3. 미션 후 **피드백 공유 및 개선**
4. **주차별 미션 제출**
    - 매주 **워크북과 미션을 제출**합니다. (디자인은 개인 보완 가능)
    - 워크북 완료 후 [**워크북 피드백 폼 제출**](https://forms.gle/aXPWVZpDSfYTAiCd6?utm_source=chatgpt.com)
        - 특정 주제에 많은 피드백 요청이 들어올 경우, 피드백 이후 해당 내용을 바탕으로 **추가 강의 영상** 제공 예정 ([유튜브 구독](https://www.youtube.com/@yongcoding?utm_source=chatgpt.com))
    - **🍠 코드 리뷰 제출 기준**
        - 본인이 리뷰한 코드 **최소 1개**
        - 본인이 받은 리뷰를 코드에 **실제 반영한 것 최소 1개**
5. **스터디 인증샷**
    - 매주 대표 사진 **1장** 남기기
    - 이미지 임베드 또는 복사·붙여넣기 가능

# 📸 잠깐 ! 스터디 인증샷은 찍으셨나요?📸

---

* 스터디리더께서 대표로 매 주차마다 한 장 남겨주시면 좋겠습니다!🙆💗
 (사진을 저장해서 이미지 임베드를 하셔도 좋고, 복사+붙여넣기해서 넣어주셔도 좋습니다!)

[]()

# 🎯 핵심 키워드

---

<aside>
💡 주요 내용들에 대해 조사해보고, 자신만의 생각을 통해 정리해보세요!
레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 됩니다.
조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**

🍠 이모지가 달린 부분은, 여러분들이 직접 조사하여, 추가 작성하거나, 실습해보실 부분이니, 꼭 진행해주셔야 합니다!

</aside>

### 키워드 정리 🍠

- **useMutation**
    - **useMutation**은 무엇인가요?
        
        # **useMutation**은 무엇인가요?
        
        ---
        
        ### 서버 상태 관리가 없던 시절의 비극
        
        **TanStack Query** 같은 라이브러리가 없으면, 데이터를 변경할 때마다 개발자는 다음과 같은 **데이터 불일치**의 늪에 빠집니다.
        
        [Mutations | TanStack Query React Docs](https://tanstack.com/query/v5/docs/framework/react/guides/mutations)
        
        기존에 할 일이 10개의 데이터가 있었다고 가정해볼게요.
        
        1. **할 일 추가 요청 (POST) 성공!** 🎉 
        2. 서버에는 10개 → 11개의 할 일이 됩니다. (✅ 서버 상태 업데이트)
        3. 하지만 **화면(클라이언트)** 은 여전히 10개의 목록만 보여줍니다. (❌ 화면 상태는 그대로)
        4. **사용자는 새로 추가된 할 일을 볼 수 없습니다! (실제로 데이터베이스에는 추가된 할 일이 있음)**
        
        이때 개발자는 **Mutation (추가 작업)**이 성공할 때마다 **Query (목록 가져오기)**를 수동으로 다시 실행하는 코드를 **매번** 직접 작성해야 했습니다. (수동 Re-fetch → 복잡하고 실수하기 쉬움)
        
        ---
        
        ### useMutaiton의 핵심 역할: 변경 작업의 표준화
        
        `useMutation`은 서버에 데이터를 변경(**POST**/**PUT**/**DELETE**)하는 작업을 수행하고, 그 결과를 체계적으로 관리합니다.
        
        | **속성** | **역할** |
        | --- | --- |
        | `mutationFn` | 실제로 서버에 변경 요청을 보내는 **비동기 함수** (예: `createTodo`) |
        | `isPending` | 요청이 진행 중인지 (`추가 중...`) |
        | `isError` | 요청이 실패했는지 (`에러 발생!`) |
        | `onSuccess` | 요청이 **성공한 직후** 실행되는 함수 (⭐ 가장 중요!) |
        | `.mutate()` | 변경 작업을 **실행**하는 함수 (여기에 Payload 전달) |
        
        ---
        
        ### 🛠️ 실습: `useMutation`으로 안전하게 변경하기
        
        이번 실습의 목표는 다음과 같습니다.
        
        **목표:** **할 일 추가**(`createTodo`)에 성공하면, **할 일 목록**(`['todos']` 키)을 **자동으로 새로고침**하게 만들기.
        
        실제로, 내부 코드의 구현은 하지 않을 겁니다. 우리가 실제 서버가 아닌, 실제로 네트워크 요청이 가지만 가상 서버를 사용하기 때문에 눈으로 업데이트 현황을 보지 못하기 때문입니다.
        
        진짜 실습은 미션에서 같이 함께 진행 할 예정이지만 결국에 코드 자체는 크게 다르지 않기 때문에 이렇게 쓰는 구나 정도로만 기억하시면 좋을 것 같아요.
        
        **1단계: API 유틸 준비 (생성/삭제 함수)**
        
        ```tsx
        // apis/todos.ts
        export const createTodo = async (payload: Pick<Todo, 'title' | 'completed'>): Promise<Todo> => {
          // POST 요청으로 새로운 할 일을 생성
          // ... (생략)
        };
        
        export const deleteTodo = async (id: number): Promise<{ success: boolean; id: number }> => {
          // DELETE 요청으로 할 일을 삭제
          // ... (생략)
        };
        ```
        
        **2단계: 목록은 `useQuery`로 가져오기**
        
        목록을 가져오는 `TodoList` 컴포넌트는 `['todos']` 키를 사용합니다. **이 키가 Mutation 성공 후 동기화의 대상이 됩니다.**
        
        ```tsx
        // components/TodoList.tsx
        import { useQuery } from '@tanstack/react-query';
        
        const fetchTodos = async (): Promise<TodoResponse[]> => {
          // 목록 가져오기 함수
          // ... (생략)
        };
        
        export const TodoList = () => {
          const { data, isPending } = useQuery({
            queryKey: ['todos'], // 👈 이 키를 useMutation에서 사용합니다!
            queryFn: fetchTodos,
            // ... (생략)
          });
          // ... (렌더링 로직 생략)
        };
        ```
        
        **3단계: `useMutation`으로 변경하고 자동 동기화 설정하기 ⭐**
        
        `useMutation`을 사용해 할 일 **생성** 작업을 정의합니다. 성공 후 `qc.invalidateQueries`를 통해 목록(`['todos']`)을 **자동으로** 동기화합니다.
        
        ```tsx
        // components/TodoActions.tsx
        import { useMutation, useQueryClient } from '@tanstack/react-query';
        import { createTodo } from '../apis/todos';
        // ... (생략)
        
        export const TodoActions = () => {
          const qc = useQueryClient();
          // ... (useState 생략)
        
          const create = useMutation({
            mutationKey: ['createTodo'],
            mutationFn: createTodo,
            // 🔥 Mutation의 핵심!
            // 1. 서버 변경(POST) 성공 시 실행. (네트워크 요청 성공)
            // 2. ['todos'] 키를 가진 캐시를 '만료됨(Stale)'으로 표시합니다. (invalidateQueries)
            onSuccess: () => qc.invalidateQueries({ queryKey: ['todos'] }),
          });
        
          return (
            <div style={{ display: 'grid', gap: 8 }}>
              <div>
                {/* ... (input 생략) */}
                <button
                  onClick={() => title.trim() && create.mutate({ title: title.trim(), completed: false })}
                  disabled={create.isPending}
                >
                  {create.isPending ? '추가 중...' : '추가'}
                </button>
                {create.isError && <span>에러: {(create.error as Error).message}</span>}
              </div>
              {/* ... (Update/Delete 버튼 생략) */}
            </div>
          );
        };
        ```
        
        ---
        
        **🎯 `invalidateQueries`의 마법!**
        
        1. 사용자가 **'추가'** 버튼 클릭 → `create.mutate()` 실행.
        2. `createTodo` 함수가 서버에 요청을 보냄. (진행 중: `create.isPending` = `true`)
        3. 서버 요청 **성공** → `onSuccess` 실행.
        4. `qc.invalidateQueries({ queryKey: ['todos'] })` 가 **실행되자마자**, TanStack Query는 `TodoList` 컴포넌트가 사용하는 `['todos']` 데이터를 "오래되었으니 다시 가져와야 해!"라고 표시합니다.
        5. TanStack Query가 **자동으로** `fetchTodos` 함수를 **재실행(Re-fetch)** 하여 최신 목록을 가져오고, 화면에 **자동**으로 반영합니다.
        
        **개발자는 수동으로 `fetchTodos`를 다시 호출할 필요가 없습니다.** 이것이 바로 서버 상태 관리 라이브러리를 사용하는 가장 큰 이유입니다!
        
    - **useMutation**의 핵심 옵션
        
        # useMutation의 핵심 옵션
        
        ---
        
        `useMutation`은 단순히 데이터 변경 요청만 하는 게 아니에요. 요청이 진행되는 **전 과정**을 세밀하게 제어할 수 있는 다양한 도구를 제공해요. 이 도구들을 **"라이프사이클"** 옵션이라고 부르기도 해요.
        
        ### **1. 필수 옵션: 변경 작업을 정의해요**
        
        | **옵션** | **무슨 일을 하나요?** | **왜 사용해야 하나요?** |
        | --- | --- | --- |
        | **`mutationFn`** | **실제로 서버에 데이터를 보내는 함수**를 지정해요. 이 함수가 POST, PUT, DELETE 같은 비동기 API 호출을 담당해요. | **가장 핵심**이에요. 어떤 데이터를 어떻게 변경할지 여기에 정의해야 해요. |
        
        ---
        
        ### 2. 라이프사이클 옵션: 변경 전/중/후를 제어해요
        
        이 옵션들은 `mutate()` 함수가 실행될 때, 그 과정의 특정 시점에 맞춰 자동으로 실행되는 콜백 함수들이에요.
        
        | **옵션** | **실행 시점** | **핵심 용도** |
        | --- | --- | --- |
        | **`onMutate`** | **요청이 서버로 보내지기 직전**에 호출돼요. | 🚀 **낙관적 업데이트 (Optimistic Update)**를 할 때 사용해요. 목록을 미리 변경해두고, 요청 실패 시 되돌릴 (롤백) 데이터를 저장할 수 있어요. |
        | **`onSuccess`** | 요청이 **성공적**으로 완료되었을 때 호출돼요. | ✅ **데이터를 동기화**해요. `invalidateQueries`를 사용해서 목록을 자동으로 새로고침하게 만들어요. |
        | **`onError`** | 요청 도중 **에러가 발생**했을 때 호출돼요. | 🚨 에러 메시지를 사용자에게 보여주고, `onMutate`에서 변경했던 데이터를 **원래대로 롤백**할 때 사용해요. |
        | **`onSettled`** | 성공이든 실패든, **모든 작업이 끝났을 때** 호출돼요. | 🧹 성공/실패와 관계없이 마지막으로 **로딩 상태를 해제**하거나, 최종 정리 작업을 할 때 유용해요. |
        
        ---
        
        ### 3. 설정 옵션: 안정성과 제어를 강화해요
        
        | **옵션** | **무슨 일을 하나요?** | **왜 사용해야 하나요?** |
        | --- | --- | --- |
        | **`retry`** | Mutation이 실패했을 때, **몇 번까지 자동으로 다시 시도**할지 정해요. | 네트워크 연결이 불안정할 때처럼 일시적인 오류는 재시도를 통해 **자동으로 해결**할 수 있어요. |
        | **`retryDelay`** | 재시도 사이에 **얼마나 기다릴지** 시간을 정해요. | 서버에 부담을 주지 않도록 연속적인 요청 사이에 **적절한 간격**을 두는 데 사용돼요. |
        | **`throwOnError`** | 에러가 났을 때, TanStack Query 내부에서 에러를 잡지 않고 **밖으로 던질지** 정해요. | 상위 컴포넌트의 `ErrorBoundary` 같은 곳에서 **통합적으로 에러를 처리**하고 싶을 때 `true`로 설정해요. |
        | **`meta`** | 이 Mutation에 대한 **추가 정보**를 넣을 수 있어요. | 디버깅을 하거나, 커스텀 로깅 도구에 이 요청이 어떤 것인지 알려주고 싶을 때 사용돼요. |
        
- **낙관적 업데이트(OptimisticUpdate)  🍠**
    - **낙관적 업데이트(OptimisticUpdate)**는 무엇인가요?
        
        # OptimisticUpdate는 무엇인가요?
        
        ---
        
        **낙관적 업데이트**는 말 그대로 **"낙관적인(Optimistic)"** 생각에서 출발하는 사용자 경험(UX) 개선 기법이에요.
        
        사용자가 버튼을 클릭해서 데이터를 변경할 때 (예: 할 일 목록에 새 항목 추가), 우리는 보통 서버에 요청을 보내고 그 결과를 기다려요. 하지만 이 과정에서 네트워크 지연 때문에 0.5초에서 1초 정도의 **"기다림"**이 생길 수 있어요.
        
        낙관적 업데이트는 이 기다리는 시간을 줄여주기 위해 다음과 같이 작동해요.
        
        > **핵심 아이디어:** **"어차피 요청은 성공할 거야!"** 라고 미리 가정하고, 서버 응답이 오기 전에 **클라이언트(화면)를 먼저 바꿔버리는** 거예요.
        > 
        
        ---
        
        ### 주요 개념: 빠른 피드백과 롤백 보험
        
        | **개념** | **쉽게 설명하면?** |
        | --- | --- |
        | **즉각적인 UI 업데이트** | 사용자가 **'추가'** 버튼을 누르는 **동시에** 화면에 새로운 항목이 나타나요. 서버 요청의 성공 여부는 나중에 확인해요. |
        | **가정 (낙관)** | "이 요청은 **99% 성공할 것이다**"라고 믿고 UI를 변경해요. 마치 **'외상'**으로 물건을 먼저 주고, 돈(서버 응답)은 나중에 받는 것과 같아요. |
        | **에러 처리 및 롤백** | 만약 서버 요청이 **실패**하면, 방금 미리 보여줬던 변경 사항을 **취소(롤백)**하고, 사용자에게 **"죄송해요, 에러가 났어요"**라고 알려줘요. |
        
        ---
        
        ### 장점 : 사용자 만족도를 높여줘요 👍
        
        - **즉각적인 반응:** 사용자는 자기 행동에 대한 피드백을 바로 받기 때문에 앱이 **매우 빠르다**고 느껴요. 기다림이 거의 없어져요.
        - **네트워크 지연 무시:** 네트워크가 약간 느리더라도 사용자는 그 지연을 체감하지 못해요. 사용자 경험(UX)이 확 좋아져요.
        
        ---
        
        ### 단점: 복잡한 보험 처리 😟
        
        - **복잡한 롤백 로직:** 서버 요청이 실패했을 때, **'원래 상태'**가 무엇이었는지 정확하게 기억하고 있다가 그 상태로 **되돌리는 (롤백)** 로직을 추가해야 해요.
        - **일시적인 불일치:** 잠시 동안 클라이언트 화면과 서버의 실제 데이터가 다를 수 있어요. (이건 롤백 성공 시 해결돼요.)
    - Tanstack Query에서 **낙관적 업데이트(OptimisticUpdate)** 구현하기
        
        # Tanstack Query에서 **낙관적 업데이트(OptimisticUpdate)** 구현하기
        
        ---
        
        TanStack Query는 `useMutation`의 **라이프사이클 옵션**을 통해 이 복잡한 낙관적 업데이트와 롤백 과정을 표준화해줘요.
        
        이때 핵심적으로 사용되는 훅은 `onMutate`와 `onError` 옵션이에요.
        
        | **옵션** | **낙관적 업데이트에서 무슨 역할을 하나요?** |
        | --- | --- |
        | **`onMutate`** | 1. **이전 데이터 (Context) 저장:** 변경 직전의 데이터를 `context`에 임시로 저장해서 **나중에 롤백**할 수 있도록 준비해요. 2. **캐시 데이터 즉시 변경:** `setQueryData`를 사용해서 서버 응답 없이도 **미리 UI를 업데이트**해요. |
        | **`onError`** | 서버 요청이 실패하면, `onMutate`에서 저장해둔 **이전 데이터 (`context`)**를 꺼내와서 `setQueryData`로 캐시를 복구하고 **UI를 원래대로 롤백**해요. |
        | **`onSettled`** | 최종적으로 (성공이든 실패든) 이 Mutation과 관련된 **목록을 새로고침 (`invalidateQueries`)**해서 서버의 최종 상태와 클라이언트를 확실하게 동기화해요. |
        
        이렇게 TanStack Query는 개발자가 수동으로 처리해야 했던 **낙관적인 가정**과 **실패 시 롤백** 과정을 체계적인 훅 라이프사이클로 관리해줘서 안정성을 높여준답니다.
        
        <aside>
        💡
        
        실제로, **낙관적 업데이트(OptimisticUpdate)**는 아래 미션에서 함께 진행 할 예정이에요
        
        - UMC 9th 중앙 웹 파트장 매튜/김용민 -
        
        </aside>
        
    - 어떤 상황에서 **낙관적 업데이트(OptimisticUpdate)가 효율적일까요? 🍠**
        
        # 어떤 상황에서 **낙관적 업데이트(OptimisticUpdate)가 효율적일까요? 🍠**
        
        ---
        
        > **낙관적 업데이트(OptimisticUpdate)가 효율적인 상황은 언제일까요? 🍠**
        > 
        
        <aside>
        📌
        
        낙관적 업데이트는 서버 요청의 성공 확률이 매우 높은 작업(예: '좋아요' 누르기, 닉네임 변경, 할 일 완료 체크)에 가장 효율적이다. 서버 응답을 기다리는 딜레이(latency) 없이 UI가 즉시 반응하기 때문에, 사용자는 앱이 매우 빠르고 부드럽게 작동한다고 느끼게 된다.
        
        </aside>
        
        > **낙관적 업데이트(OptimisticUpdate)를 피해야 하는 상황 언제일까요? 🍠**
        > 
        
        <aside>
        📌
        
        데이터의 정합성이 매우 중요하거나 서버 측 유효성 검사로 인해 실패할 확률이 높은 작업(예: 결제, 송금, 좌석 예약, 중복 확인이 필요한 ID 생성)에는 피해야 한다. 만약 작업이 실패했을 때 UI를 이전 상태로 롤백(rollback)시키는 과정이 사용자에게 더 큰 혼란을 줄 수 있기 때문이다.
        
        </aside>
        
    - **낙관적 업데이트(OptimisticUpdate) 블로그 읽고 개념 정리하기 🍠**
        
        # **낙관적 업데이트(OptimisticUpdate) 블로그 읽고 개념 정리하기 🍠**
        
        ---
        
        [개발자 매튜 | 실제 서비스에서 낙관적 업데이트(Optimistic Update)를 활용하여, 유저의 답답함 줄이기](https://www.yolog.co.kr/post/optimistic-update)
        
        - **낙관적 업데이트(OptimisticUpdate)**를 왜 도입해야 하는지, 이 패턴이 해결하려는 문제를 실제 서비스 맥락에서 설명해보세요.
            
            낙관적 업데이트는 '좋아요'처럼 서버 응답을 기다리는 딜레이(Latency)를 제거하기 위해 도입하는 패턴이다. 이 패턴은 "어차피 이 요청은 99% 성공할 것이다"라고 낙관하고, 서버 응답이 오기 전에 UI를 즉시 변경하여 사용자 경험(UX)을 극대화한다. 기존 방식이 [클릭 → 로딩 → UI 변경]이라면, 낙관적 방식은 [클릭 → 즉시 UI 변경 → (백그라운드 통신)] 순서로 작동한다. 결과적으로 사용자는 딜레이를 전혀 느끼지 못해 앱이 매우 빠르다고 인식하게 된다.
            
        - TanStack Query 기반 구현 흐름을 `onMutate → (mutate) → onError → onSettled` 순서로 기술해주세요..
            
            onMutate: API 요청 전에 실행되며, 롤백을 위해 이전 데이터(스냅샷)를 context에 저장하고 setQueryData로 캐시를 즉시 업데이트한다. (mutate): onMutate 직후, 실제 API 요청(mutationFn)이 백그라운드에서 실행된다. 
            
            onError: API 요청이 실패하면, onMutate에서 저장한 context의 스냅샷을 가져와 setQueryData로 캐시를 롤백시킨다. 
            
            onSettled: 항상 마지막에 실행되며, invalidateQueries를 호출해 서버의 "진짜" 데이터와 UI를 최종 동기화하여 데이터 정합성을 보장한다.
            
        - ToDo “생성” 및 “좋아요 토글”에 **낙관적 업데이트(OptimisticUpdate)**를 적용했을 때의 **실패/충돌 롤백 전략**을 설계해주세요.
            
            "좋아요"와 "생성" 모두 **onMutate**에서 queryClient.getQueryData()로 롤백에 필요한 이전 캐시 데이터(스냅샷)를 context 객체로 반환한다. 만약 API 요청이 **onError**로 실패하면, 이 context에 담긴 스냅샷을 꺼낸다. queryClient.setQueryData()를 호출하여 캐시를 이 스냅샷으로 강제로 되돌려 UI를 롤백시킨다. "생성"의 경우 실패 알림을 띄우고, "좋아요"는 UI가 원래대로 돌아가는 것만으로도 사용자에게 롤백을 알릴 수 있다.
            
        

# 🍠  미션 1. **useMutation**을 활용하여 서버 상태 손쉽게 관리하기

---

<aside>
🍠 데이터를 **추가, 수정, 삭제(CUD)**하는 모든 작업에서 **useMutation**을 표준으로 사용하고, 성공 후 `invalidateQueries`를 통해 화면을 자동으로 동기화하는 방법을 완벽하게 익힙니다. 

이것이 바로 서버 상태 관리의 핵심이에요!

**- 중앙 웹 파트장 매튜 김용민 -**

</aside>

---

### 🎥 강의 영상

<aside>
🍠

만약 미션을 진행하다가 막히는 부분이 생긴다면, 아래 방법을 활용해 문제를 해결해보세요.

1. **공식 문서와 검색을 최우선으로 활용해 주세요.**
    - **가장 빠르고 정확한 해답**을 찾을 수 있는 가장 좋은 방법입니다.
    - 에러 메시지나 궁금한 점을 직접 검색하며 스스로 답을 찾는 연습을 해보세요.
2. **그래도 해결되지 않을 때 AI에게 물어보세요.**
    - AI는 방대한 지식을 바탕으로 여러분이 겪는 문제를 해결하는 데 큰 도움을 줄 수 있습니다.
    - 에러 코드, 원하는 기능, 현재까지 작성한 코드 등을 함께 질문하면 더욱 정확한 답변을 얻을 수 있습니다.
3. **마지막 수단으로 영상을 활용해 주세요.**
    - 영상을 처음부터 끝까지 보기보다는, **필요한 부분만 찾아서** 미션을 해결하는 데 힌트를 얻는 용도로 활용해 보세요.

**- 중앙 웹 파트장 매튜 김용민 -**

</aside>

https://www.youtube.com/watch?v=vaUxI_I6WvI&t=1780s

### ✅ 미션 체크리스트

---

### LP 글 작성 모달 구현

- [x]  우측 하단의 **`+`** 버튼 클릭 시 글 작성 모달이 열려야 합니다.
    - [x]  모달 바깥 영역 클릭 또는 **'X' 버튼** 클릭 시 모달이 닫히도록 사용자 친화적인 UX를 구현해야 합니다.
        
        ![Screenshot 2025-03-06 at 8.19.38 PM.png](attachment:b925f819-46c6-4a9d-a41c-20f05ead75c4:Screenshot_2025-03-06_at_8.19.38_PM.png)
        
    - [x]  LP **사진을 입력받을 수 있는 `input type="file"`** 형태의 입력 창을 띄워주세요.
        
        [화면 기록 2025-04-02 오후 5.03.48.mov](attachment:41041d08-9543-4518-a0f2-6b5dd3c13b22:화면_기록_2025-04-02_오후_5.03.48.mov)
        

---

### Tag 추가 삭제 및 LP 게시글 생성 기능

- [x]  태그 입력 후  버튼 클릭으로 태그가 추가되어 UI에 표시되어야 합니다.
    
    [화면 기록 2025-04-02 오후 5.00.32.mov](attachment:5e4ee2d7-6ea6-4c09-9cee-5ee944ea747b:화면_기록_2025-04-02_오후_5.00.32.mov)
    
- [x]  각 태그 옆의 **`x` 버튼**을 누르면 위의 영상 처럼 해당 태그가 즉시 삭제되는 **클라이언트 상태 관리** 로직을 구현해주세요.
- [x]  **'Add LP'** 버튼 클릭 시, **useMutation**을 이용하여 LP Post API를 호출해야 합니다.
    - [x]  **POST 요청 성공 시**, 모달이 닫히고 메인 페이지의 LP 목록이 **`onSuccess`** 내부의 `invalidateQueries`를 통해 자동으로 새로고침되어야 합니다.

---

### 댓글 기능

- [x]  6주차 댓글 레이아웃에 **useMutation**을 연결하여 댓글 작성 API를 호출합니다.
    - [x]  **댓글 생성 요청 성공 시**, 댓글 목록 **`queryKey`**를 **`invalidateQueries`**하여 작성한 댓글이 목록에 즉시 반영되도록 구현해야 합니다.
    
    ![스크린샷 2025-04-02 오후 5.12.35.png](attachment:d58a7e5d-9765-4605-9645-b1a41a33170d:스크린샷_2025-04-02_오후_5.12.35.png)
    
- [x]  본인이 작성한 댓글에 한하여 메뉴 버튼 (…버튼)을 누르면 수정 혹은 삭제를 할 수 있는 버튼을 만들고, 수정 기능, 삭제기능도 **useMutation**을 이용하여 구현해주세요!
    
    ![스크린샷 2025-04-02 오후 5.13.32.png](attachment:41bd4164-0829-4283-a832-af7a760c0eb6:스크린샷_2025-04-02_오후_5.13.32.png)
    
    - [x]  **댓글 수정 요청 성공 시**, 댓글 목록 **`queryKey`**를 **`invalidateQueries`**하여 수정한 댓글 내용이 목록에 즉시 반영되도록 구현해야 합니다.
    - [x]  **댓글 삭제 요청 성공 시**, 댓글 목록 **`queryKey`**를 **`invalidateQueries`**하여 삭제한 댓글이 목록에 즉시 반영되도록 구현해야 합니다.

---

### 마이 페이지

- [x]  설정 버튼을 누르면 본인의 이름, bio, 프로필 사진을 수정하는 UI를 띄우고, **useMutation**을 이용하여 수정 기능을 구현해야 합니다.
    
    ![스크린샷 2025-04-02 오후 4.29.57.png](attachment:e8c5191e-d25e-4e3e-a867-bbe8dcdc5df2:스크린샷_2025-04-02_오후_4.29.57.png)
    
    - [x]  **Bio, 프로필 사진:** 옵션이므로 값이 비어있어도 저장이 가능하도록 처리해야 합니다.

---

### 인증 관련

- [x]  기존 로그인 로직을 **useMutation**으로 변경해주세요. (회원가입은 다음 주차에서 다룰거라 로그인만 해주시면 됩니다!)
- [x]  로그인은 서버 상태(인증 토큰)를 **변경**하는 작업이므로 **useMutation**을 사용하며, 성공 시 홈 화면으로 리다이렉션되어야 합니다.
- [x]  사이드바의 '탈퇴하기' 버튼 클릭 시, **확인 모달**을 띄워 최종 동의를 받아야 합니다.
    
    ![스크린샷 2025-04-02 오후 4.32.40.png](attachment:6711f611-1d14-4176-ba6d-c6a64feb442c:스크린샷_2025-04-02_오후_4.32.40.png)
    
    - [ ]  '예'를 누른 경우에만 **useMutation**을 이용해 탈퇴 API를 호출하고, 성공 시 로그인 페이지로 이동 처리해야 합니다.
- [ ]  네비게이션 바에 있는 로그아웃 버튼을 누르면 로그아웃이 되도록 **useMutation**을 이용하여 구현해주세요

---

### LP 상세 조회 기능

- [x]  상세 페이지에서 **수정, 삭제** (위에서 구현한 기능 재활용) 및 **좋아요 기능**을 구현해야 합니다. (좋아요는 미션 2로 넘겨서 Optimistic Update를 적용할 예정입니다.)
    
    [화면 기록 2025-04-02 오후 5.09.54.mov](attachment:f6dd6f4a-253c-4abd-a6c5-2bb7bb6e679c:화면_기록_2025-04-02_오후_5.09.54.mov)
    

### 🍠  미션 1. 제출

- 깃허브 주소
- 실행 영상

# 🍠 미션 2. **낙관적 업데이트(OptimisticUpdate)** 를 활용해서 빛보다 빠르게 업데이트 하기

---

<aside>
🍠 `useMutation`의 강력한 라이프사이클 옵션(`onMutate`, `onError`)을 활용하여, 서버 응답을 기다리지 않고도 UI를 즉시 업데이트하는 **`낙관적 업데이트(Optimistic Update)`**를 경험합니다. 이는 사용자 경험을 혁신적으로 개선하는 핵심 기법을 이번 미션을 통해서 함께 학습해보는 것이 핵심입니다.

**- 중앙 웹 파트장 매튜 김용민 -**

</aside>

---

### 🎥 강의 영상

<aside>
🍠

만약 미션을 진행하다가 막히는 부분이 생긴다면, 아래 방법을 활용해 문제를 해결해보세요.

1. **공식 문서와 검색을 최우선으로 활용해 주세요.**
    - **가장 빠르고 정확한 해답**을 찾을 수 있는 가장 좋은 방법입니다.
    - 에러 메시지나 궁금한 점을 직접 검색하며 스스로 답을 찾는 연습을 해보세요.
2. **그래도 해결되지 않을 때 AI에게 물어보세요.**
    - AI는 방대한 지식을 바탕으로 여러분이 겪는 문제를 해결하는 데 큰 도움을 줄 수 있습니다.
    - 에러 코드, 원하는 기능, 현재까지 작성한 코드 등을 함께 질문하면 더욱 정확한 답변을 얻을 수 있습니다.
3. **마지막 수단으로 영상을 활용해 주세요.**
    - 영상을 처음부터 끝까지 보기보다는, **필요한 부분만 찾아서** 미션을 해결하는 데 힌트를 얻는 용도로 활용해 보세요.

**- 중앙 웹 파트장 매튜 김용민 -**

</aside>

https://www.youtube.com/watch?v=fyA8t6lwR7g&t=2070s

---

### ✅ 미션 체크리스트

---

### 닉네임 변경

- [x]  **마이페이지에서 닉네임 변경** 요청 시, 서버의 응답(성공/실패)을 기다리기 전에 `onMutate`를 사용하여 Nav-Bar와 마이페이지의 닉네임을 **즉시 변경**해야 합니다.
    
    [화면 기록 2025-04-02 오후 5.21.16.mov](attachment:151fcbb2-ea18-428e-bfbf-0e95a7864c26:화면_기록_2025-04-02_오후_5.21.16.mov)
    
- [x]  게시글 상세 조회에서 좋아요를 누를 때 **낙관적 업데이트(OptimisticUpdate)** 를 이용하여 바로 좋아요가 반영되도록 구현해주세요
    
    [화면 기록 2025-04-02 오후 5.16.56.mov](attachment:ac696d3f-7958-4a68-a479-5756be5ac3b5:화면_기록_2025-04-02_오후_5.16.56.mov)
    

---

### 🍠  미션 2. 제출

- 깃허브 주소
- 실행 영상

# 🍠 워크북 피드백

---

<aside>
💡

여러분들이 워크북을 학습하며 느낀 **좋았던 점**, **아쉬웠던 점**, **개선이 필요한 부분**을 자유롭게 남겨주세요.

여러분의 솔직한 의견은 다음 기수와 현재 진행하고 있는 웹 파트 스터디를 더 발전시키는 데 큰 힘이 됩니다. 🙌

**📌 설문 안내**

**제출 시점 :** 각 주차 워크북 학습을 마친 뒤 **반드시 제출**해주세요.

(제출하지 않으면 해당 주차 **워크북 미이수**로 간주됩니다.)

</aside>

[](https://forms.gle/PCLJq6NUn1qBd1Ha8)

# 🍠 코드 리뷰

---

<aside>
💡

워크북 하단에 아래 내용을 정리해 제출해 주세요. (제출용 폼은 추후 제공 예정)

1. **내가 리뷰한 내용**
    - 직접 리뷰한 코드 내용을 캡처하여 업로드 (**`GitHub Pull Request`** 캡처 권장)
2. **리뷰 반영 결과**
    - 받은 피드백을 반영한 개선된 코드와 그 캡처를 함께 업로드 (**`GitHub Pull Request`** 캡처 권장)

> 💬 아직 코드 작성을 하지 않은 경우
> 
> 
> 스터디 참여 인증 또는 워크북 피드백을 작성해 제출해 주세요.
> 
</aside>

- 내가 리뷰한 내용을 캡처해 업로드
    
    **예시**
    
    ![스크린샷 2025-09-05 오후 12.46.40.png](attachment:39549968-68c3-4416-b41f-423fd1f7fd79:스크린샷_2025-09-05_오후_12.46.40.png)
    
- 받은 리뷰를 반영하여 개선한 코드와 캡처 업로드
    
    **예시**
    
    ![스크린샷 2025-09-05 오후 12.47.34.png](attachment:01011e3f-c9fd-4041-bdd5-4da72a805955:스크린샷_2025-09-05_오후_12.47.34.png)
    

# 🍠 트러블 슈팅

---

<aside>
🍠 실습을 진행하면서 생긴 문제들 또는 어려웠던 내용에 대해서, 이슈 - 문제 - 해결 순서로 작성해 주세요.

</aside>

- 🍠 이슈 No.1 (예시, 서식만 복사하시고 지워주세요.)
    
    **`이슈`**
    
    👉 React 상태 관리 중 `useState`로 배열을 업데이트할 때, 원본 배열이 변경되지 않는 문제가 발생했다.
    
    ---
    
    **`문제`**
    
    👉 `push()` 메서드를 사용해 상태 배열에 새 요소를 추가했지만, React가 상태 변경을 감지하지 않아 화면이 갱신되지 않았다.
    
    ```jsx
    const [items, setItems] = useState<string[]>([]);
    
    function addItem(newItem: string) {
      items.push(newItem); // 상태 직접 변경
      setItems(items);     // 동일 참조 전달
    }
    ```
    
    React는 상태 변경 여부를 **참조(Reference)** 기준으로 판단하기 때문에, 기존 배열을 직접 변경하면 리렌더링이 일어나지 않는다.
    
    ---
    
    **`해결`**
    
    👉 기존 배열을 복사하여 새로운 배열 객체를 만들어 전달했다.
    
    ```jsx
    function addItem(newItem: string) {
      setItems([...items, newItem]); // 새로운 배열 생성
    }
    ```
    
    이로써 React가 새로운 참조를 감지하여 정상적으로 리렌더링이 발생했다.
    

# 🥕 상태 관리의 이중생활: 클라이언트 vs 서버, `useMutation`이 탄생한 이유

---

<aside>
🥕

서버 상태 관리 라이브러리인 SWR과 TanStack Query를 React TypeScript 환경에서 비교하며, 왜 기존에 Redux, MobX 같은 전통적인 상태관리 라이브러리 대신 서버 상태 관리 라이브러리를 도입하는지, 그리고 최신 사용자 비율과 각각의 장단점, 기능 차이를 재밌게 정리해보았어요.

참고로, 이 글의 내용은 전부 **Perplexity**를 기반으로 정리했습니다.

</aside>

[상태 관리의 이중생활: 클라이언트 vs 서버, 그리고 `useMutation`의 탄생](https://www.notion.so/vs-useMutation-2a0b57f4596b8125b34aef354fdb649c?pvs=21)

# 🍠 학습 회고

---

<aside>
📢 이번 주차 워크북을 해결해보면서 어땠는지 **회고**해봅시다.

- **핵심 키워드**에 대해 완벽하게 이해했는지? 
- **이해한 점 - 어려운 점 (개선 방법) - 회고** 순서로 작성해주세요.
- **참고 자료**가 있다면 아래에 남겨주세요.

</aside>

- 📢 학습 회고 (예시, 서식만 복사하시고 지워주세요.)
    - **프론트엔드 배포, Vercel 활용**
        - **이해한 점**: Vercel은 프론트엔드 프로젝트를 **빠르고 간편하게 배포**할 수 있는 플랫폼입니다.
            
            GitHub 연동, 환경변수 설정, 커스텀 도메인 연결 등 배포 과정 대부분이 GUI와 CLI로 쉽게 처리되며, SPA 환경에서도 라우팅 문제를 `vercel.json` 설정으로 해결할 수 있습니다.
            
            - 예시:
                
                ```bash
                # CLI로 배포
                vercel         # Preview 배포
                vercel --prod  # Production 배포
                ```
                
                ```json
                // SPA 라우팅 문제 해결
                {
                  "routes": [
                    { "src": "/[^.]+", "dest": "/index.html", "status": 200 }
                  ]
                }
                ```
                
        - **어려운 점 (개선 방법)**: SPA 기반 프로젝트는 새로고침 시 404 문제가 발생할 수 있으며, 환경변수 관리, 커스텀 도메인 연결 과정이 처음에는 헷갈렸습니다.
            - 개선 방법: `vercel.json` 설정으로 SPA 라우팅 문제를 해결하고, Vercel Dashboard에서 환경변수와 DNS 설정을 직접 확인하면서 반복적으로 배포 실습을 진행했습니다.
            - 예시:
                
                ```tsx
                // 환경변수 사용
                const api = axios.create({
                  baseURL: import.meta.env.VITE_API_URL,
                  headers: { 'Content-Type': 'application/json' },
                });
                
                ```
                
        - **회고**: 실제 배포 과정을 경험해보니, 로컬 환경과 다른 실제 서비스 환경에서의 테스트 필요성을 이해할 수 있었습니다.
            
            앞으로 프로젝트를 진행할 때, GitHub 연동과 Vercel 배포를 활용해 **즉시 테스트 가능한 환경**을 만들고, SPA 라우팅 문제와 환경변수를 신경 써서 안정적으로 서비스를 운영할 수 있을 것 같습니다.
            
        
        ---
        
        ### 참고 자료
        
        [개발자 매튜 | 우리는 Vercel로 간다! 프론트엔드 배포 가이드](https://www.yolog.co.kr/post/vercel-deployment)
        

# 🤔 참고 자료

---

[Mutations | TanStack Query React Docs](https://tanstack.com/query/v5/docs/framework/react/guides/mutations)

[개발자 매튜 | 실제 서비스에서 낙관적 업데이트(Optimistic Update)를 활용하여, 유저의 답답함 줄이기](https://www.yolog.co.kr/post/optimistic-update/)

# 🛡️ 저작권

---

**© 2025 [Kim Yongmin (Matthew)](https://www.youtube.com/@yongcoding). All rights reserved.**